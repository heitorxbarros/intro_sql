---
title: "Introdução a bases de dados e SQL"
subtitle: "Parte 2"
author: "Heitor Barros"
institute: "FP/SUBGGC/CGRH/CTAP"
date: ""
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
---
class: center, middle
```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(
  base_color = "#004b80", 
  header_font_google = google_font("Josefin Sans"),
  text_font_google   = google_font("Montserrat", "300", "300i"),
  code_font_google   = google_font("Fira Mono"),
)
```

```{r xaringan-logo, echo=FALSE}
xaringanExtra::use_logo(
  image_url = "logo.png",
  position = xaringanExtra::css_position(top = "1em", right = "1em"),
  width = "200px"
)

```

# SQL

---
class: inverse, center, middle

# Structured Query Language

<p1 style='color:gray;font-size:24px'><i> linguagem de consultas estruturadas </i></p1>

---
### SQL

Sistemas gerenciadores de bancos de dados são manipulados através de uma linguagem padrão, desenvolvida especificamente para o ambiente relacional, denominada **SQL**. 
A linguagem SQL é composta por um reduzido conjunto de **instruções** que permitem manipular um banco de dados com diferentes finalidades.

```{r tabela, echo=F}
tibble::tibble(
  FINALIDADE = c("Recuperar dados",
                 "Manipular dados",
                 "Definir dados",
                 "Controlar transações"), 
  INSTRUÇÕES = c("SELECT",
                 "INSERT, UPDATE e DELETE",
                 "CREATE, ALTER e DROP",
                 "COMMIT e ROLLBACK"),
  DESCRIÇÃO = c("Recupera registros armazenados em tabelas do banco de dados",
                "Inserção, alteração e remoção de registros de tabelas do banco de dados. Este subconjunto de instruções da SQL é                  conhecido como DML (Data Manipulation Language)",
                "Criação, alteração e exclusão de objetos do banco de dados (ex.: tabelas, índices, etc.). Este subconjunto de                     instruções é conhecido como DDL (Data Definition Language).",
                "Gerenciam as modificações realizadas pelos comandos DML. Permitem agrupar as alterações dos dados em transações                   lógicas.")
) |> 
  gt::gt() |> 
  gt::tab_style(style = gt::cell_text(weight = "bold",size = 18), 
                locations = gt::cells_column_labels()) |> 
  gt::opt_stylize(style = 5, color = "blue", add_row_striping = F)

```

---
class: inverse, center, middle

# SELECT

---
### SELECT
No trabalho com bancos de dados e SQL, a tarefa mais comum é recuperar dados de uma ou mais tabelas. A instrução **SELECT**  nos permite realizar consultas sobre todos os registros armazenados em nossos bancos de dados. Usaremos as tabelas do <strong style="color:red;">ERGON</strong> em todos os exemplos.

--
</br></br>
Inicialmente, vamos trabalhar com a tabela <strong style="color:red;">FICHAS_FINANCEIRAS</strong>. 

```{r tabela2, echo=F}
tibble::tibble(
  ATRIBUTO = c(
    "NUMFUNC",
    "NUMVINC",
    "NUMPENS",
    "EMP_CODIGO",
    "MES_ANO_FOLHA",
    "MES_ANO_DIREITO",
    "NUM_FOLHA",
    "RUBRICA",
    "TIPO_RUBRICA",
    "VALOR",
    "LANCAMENTO",
    "EXECUCAO",
    "CORRECAO",
    "COMPLEMENTO",
    "DESC_VANT"
    ), 
  TIPO = c(
    "NUMBER(9)",
    "NUMBER(8)",
    "NUMBER(2)", 
    "NUMBER(2)",
    "DATE",
    "DATE",
    "NUMBER(8)",
    "NUMBER(8)",
    "NUMBER(1)",
    "NUMBER(11,2)",
    "NUMBER(14)",
    "NUMBER(5)",
    "NUMBER(11,2)",
    "VARCHAR2(20)",
    "VARCHAR2(1)"
           ),
  PK = c(
    NULL
  ),
  `PODE SER NULL*` = c(
    "NÃO",
    "NÃO",
    "SIM",
    "NÃO",
    "NÃO",
    "NÃO",
    "NÃO",
    "NÃO",
    "NÃO",
    "NÃO",
    "NÃO",
    "SIM",
    "SIM",
    "SIM",
    "NÃO"
    ),
  FK = c(
    NULL
  ),
  DESCRIÇÃO = c(
    "Código de identificação do funcionário",
    "Código de identificação do vínculo",
    "Código de identificação do pensionista",
    "Código de identificação da empresa",
    "Mês/Ano da folha de pagamento",
    "Mês/Ano do direito (competência)",
    "Número da folha de pagamento",
    "Código da rubrica associada ao pagamento",
    "Tipo da rubrica (1 = Mesmo mês da competência; 2 = Mês diferente da competência)",
    "Valor do pagamento",
    "Código do lançamento",
    "Número da execução da folha",
    "Correção monetária",
    "Informação adicional associada à rubrica",
    "Tipo da rubrica (1 = Vantagem; 2 = Desconto)"
  )
) |> 
  gt::gt() |> 
  # gt::data_color(columns = TIPO, apply_to = "text",colors =  c("darkgreen","darkblue","black")) |> 
  gt::data_color(columns = `PODE SER NULL*`, apply_to = "text",colors =  c("black","orangered3")) |> 
  gt::tab_options(table.font.size = 15,
                  container.width = 750,
                  container.height = 250,
                  table.align='center') |> 
  gt::tab_style(style = gt::cell_text(weight = "bold",size = 18), 
                locations = gt::cells_column_labels()) |> 
  gt::opt_stylize(style = 5, color = "blue", add_row_striping = F)

```

.footnote[\* **NULL** é uma palavra que atribui um valor nulo para um campo, célula ou código em um banco de dados.]
---
### SELECT
**Exemplo 1:** Selecionando **todos** os registros de uma tabela.  
```{sql eval = F}
SELECT * 
FROM ERGON.FICHAS_FINANCEIRAS;
```

.pull-left[
Para exibir todas as colunas de uma tabela, deve-se utilizar a palavra-chave **SELECT** seguida de um __*__ (asterisco). A tabela a ser consultada deve ser indicada após a palavra-chave **FROM**. 
</br>
No exemplo, selecionamos todos os registros da tabela <strong style="color:red;">FICHAS_FINANCEIRAS</strong>.
]
.pull-right[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600}
knitr::include_graphics("images/FICHAS_FINANCEIRAS.png")
```
]

---
### SELECT
**Exemplo 2:** Selecionando **colunas específicas** de uma tabela.
```{sql eval = F}
SELECT MES_ANO_FOLHA, NUM_FOLHA, LANCAMENTO 
FROM ERGON.FICHAS_FINANCEIRAS;
```

.pull-left[
Para selecionar colunas específicas de uma tabela a lista de nomes das colunas deve ser especificada logo após a palavra-chave **SELECT**. Os nomes das colunas devem ser separados por vírgulas.
</br>
No exemplo, selecionamos as colunas **MES_ANO_FOLHA**, **NUM_FOLHA**, **LANCAMENTO** da tabela <strong style="color:red;">FICHAS_FINANCEIRAS</strong>.
]
.pull-right[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600}
knitr::include_graphics("images/FICHAS_FINANCEIRAS2.png")
```
]

---
### SELECT 

#### **Definição 1**: Sintaxe da instrução **SELECT** básica
Uma instrução **SELECT** básica deve ser composta por ao menos duas cláusulas (partes):
1. Uma cláusula **SELECT** que especifica a coluna a ser exibida (ou lista de colunas);
2. Uma cláusula **FROM** que especifica a tabela que contém as colunas listadas na cláusula **SELECT**.

```{sql eval = F}
SELECT * | col 1, ..., col n 
FROM tabela;
```

As instruções SQL não fazem distinção entre letras maiúsculas e minúsculas. Muitas vezes as cláusulas costumam ser colocadas em linhas separadas (como na definição acima e nos exemplos anteriores) com a única finalidade de melhorar a legibilidade (ou seja: não
há problema em colocar a cláusula FROM na mesma linha da cláusula SELECT).

.footnote[\* Nesse contexto, a notação "**|**" significa **OU**.]

---
### SELECT
**Exemplo 3:** Selecionando valores sem linhas duplicadas usando a palavra-chave **DISTINCT**.
```{sql eval = F}
SELECT DISTINCT NUM_FOLHA 
FROM ERGON.FICHAS_FINANCEIRAS;
```

.pull-left[
Embora existam múltiplos registros na tabela <strong style="color:red;">FICHAS_FINANCEIRAS</strong> para cada **NUM_FOLHA**, a consulta retorna cada valor único apenas uma vez. O comportamento padrão do SQL é o oposto: se a palavra-chave **DISTINCT** não for usada, a consulta retornará valores repetidos **sem suprimir nenhuma linha**. 
]
.pull-right[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600}
knitr::include_graphics("images/FICHAS_FINANCEIRAS3.png")
```
]

---
### SELECT
A palavra **DISTINCT** também pode ser utilizada com múltiplas colunas. Com isto, todas as combinações de valores distintas das colunas podem ser identificadas. 

```{sql eval = F}
SELECT DISTINCT NUM_FOLHA, MES_ANO_FOLHA 
FROM ERGON.FICHAS_FINANCEIRAS;
```
.pull-left[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600, fig.cap='SELECT COM DISTINCT'}
knitr::include_graphics("images/FICHAS_FINANCEIRAS4.png")
```
]
.pull-right[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600, fig.cap='SELECT SEM DISTINCT'}
knitr::include_graphics("images/FICHAS_FINANCEIRAS5.png")
```
]
---
### SELECT 
**Exemplo 4:** Definindo rótulos (apelidos) para as colunas.
```{sql eval = F}
SELECT DISTINCT NUM_FOLHA AS FOLHA, MES_ANO_FOLHA AS MES 
FROM ERGON.FICHAS_FINANCEIRAS;
```
.pull-left[
<p style='font-size:18px;align=justify'>
Ao exibir o resultado de uma consulta, os nomes das colunas selecionadas é exibido no cabeçalho por padrão. No entanto, podemos definir novos rótulos para as colunas na cláusula <strong>SELECT</strong>. Para isso, podemos usar o termo <strong>AS</strong> após o nome da coluna (ex.: NUM_FOLHA AS FOLHA). Na maioria dos SGBDs, o uso do termo <strong>AS</strong> é opcional e pode ser suprimido (ex.: NUM_FOLHA FOLHA). Alguns SGBDs, como o ORACLE, permitem o uso de espaços e caractéres especiais (tais como “*”, “#” ou “$”). Nesse caso, é preciso definir o nome do rótulo entre aspas duplas (ex.: NUM_FOLHA "NÚMERO FOLHA").
</p>
]
.pull-right[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600}
knitr::include_graphics("images/FICHAS_FINANCEIRAS6.png")
```
]
---
### SELECT 
#### **Definição 2**: Sintaxe estendida da instrução **SELECT** básica
Uma instrução **SELECT** pode **opcionalmente** conter rótulos para as colunas. Também de maneira opcional, uma instrução SQL pode fazer uso da palavra-chave **DISTINCT** para suprimir linhas repetidas. Com isto, o quadro a seguir apresenta o modelo estendido para a sintaxe de uma instrução **SELECT** (as partes opcionais são exibidas entre colchetes).   

```{sql eval = F}
SELECT [DISTINCT] * | col 1 [AS apelido 1], ..., col n [AS apelido n]
FROM tabela;
```
---
class: inverse, center, middle

# WHERE

---
class: center, middle

# Restringindo conjuntos de dados

---
### WHERE

Ao trabalhar com bases de dados, podemos estar interessados em recuperar apenas parte de uma tabela. Para isso, podemos usar uma cláusula para **limitar** quais linhas vamos selecionar. Além disso, ao lidar com grandes bases de dados, muitas vezes é inviável recuperar tabelas completas devido ao custo operacional. A instrução **WHERE** nos permite filtrar os dados usando um ou mais critérios.  

---
### WHERE
**Exemplo 5:** Selecionando todos os registros de uma tabela com uma **característica específica**.  
```{sql eval = F}
SELECT * 
FROM ERGON.FICHAS_FINANCEIRAS 
WHERE MES_ANO_FOLHA = '01/09/2023';
```

.pull-left[
No exemplo, a instrução **SELECT** recupera os registros da tabela <strong style="color:red;">FICHAS_FINANCEIRAS</strong> cujo valor da coluna **MES_ANO_FOLHA** seja igual a <strong style="color:red;">01/09/2023</strong>. Para isso, usamos a cláusula **WHERE** após a cláusula **FROM**. 
]
.pull-right[
```{r echo=FALSE, out.width="100%", fig.align='center', dpi=600}
knitr::include_graphics("images/FICHAS_FINANCEIRAS7.png")
```
]
---
### WHERE
